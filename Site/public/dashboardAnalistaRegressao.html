<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Métricas Gerente - GateWatch</title>
    <link rel="stylesheet" href="./CSS/styleRegressao.css">
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdn.jsdelivr.net/npm/regression"></script>
</head>

<body>

    <div class="conteudoPagina">
        <div class="boxLateral">
            <div class="boxIdentificacao">
                <h1 class="fonte_perfil" id="nome_perfil">Usuário</h1>
                <h3>ANALISTA DE DADOS</h3>
            </div>
            <div class="boxOpcoes">
                <a href="index.html">
                    <div class="box">HOME</div>
                </a>
                <a href="dashboardAnalistaMetricas.html">
                    <div class="box">DASHBOARD</div>
                </a>
                <a href="dashboardAnalistaRegressao.html">
                    <div class="box" style="background-color: #41446877;">PREVISÕES</div>
                </a>
            </div>
            <a href="cadastro.html">
                <div class="boxSair">SAIR</div>
            </a>
        </div>
        <div class="conteudoMetricas">
            <div class="boxTitulo">
                <div class="selecionarTotem">
                    <select id="selectTotem" onchange="fetchMetrics()">
                        <option value="1" selected>Totem 1</option>
                        <option value="2">Totem 2</option>
                        <option value="3">Totem 3</option>
                    </select>
                    <select id="selectComp" onchange="fetchMetrics()">
                        <option value="Cpu" selected>CPU</option>
                        <option value="Ram">RAM</option>
                        <option value="Disco">DISCO</option>
                    </select>
                </div>
            </div>
            <div class="boxConteudo">
                <div class="boxComponentes">
                    <div class="ranking">
                        <h3>Ranking de Totens com Maiores Previsões na Semana Atual</h3>
                        <div class="ranking-grid" id="ranking">
                            <div id="posicao1" class="ranking-posicao"></div>
                            <div id="nome1" class="ranking-nome"></div>
                            <div id="posicao2" class="ranking-posicao"></div>
                            <div id="nome2" class="ranking-nome"></div>
                            <div id="posicao3" class="ranking-posicao"></div>
                            <div id="nome3" class="ranking-nome"></div>
                        </div>

                    </div>
                    <div class="boxMedias">
                        <div class="box1">
                            <h4>Dia com maior previsão</h4>
                            <p id="maiorPrevisao">Carregando...</p>
                        </div>
                        <div class="box2">
                            <h4>Dia com menor previsão</h4>
                            <p id="menorPrevisao">Carregando...</p>
                        </div>
                    </div>
                    <div class="boxGrafico">
                        <div class="grafico">
                            <div id="chart" style="margin-top: 0vh;"></div>
                        </div>
                    </div>
                </div>
                <div class="boxAlertas">
                    <div class="boxRankingAlertas">
                        <h3 style="text-align: center;">Dias Acima e Abaixo da Previsão</h3>
                        <div class="linha"></div>
                        <div class="conteudo-ranking">
                            <div class="acima">
                                <h4>Dias Acima:</h4>
                                <ul id="diasAcima"></ul>
                            </div>
                            <div class="abaixo">
                                <h4>Dias Abaixo:</h4>
                                <ul id="diasAbaixo"></ul>
                            </div>
                        </div>
                    </div>


                    <div class="grafico2">
                        <div id="chart2" style="margin-top: 1vh;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</body>

<script>
    nome_perfil.innerHTML = sessionStorage.NOME_USUARIO;

    // Função assíncrona para buscar métricas e previsões dos totems selecionados
    async function fetchMetrics() {
        // Obtendo os valores selecionados pelo usuário para o Totem e o Componente
        const selectedTotem = document.getElementById('selectTotem').value; // Ex.: "1", "2", etc.
        const selectedComponent = document.getElementById('selectComp').value; // Ex.: "CPU", "RAM", etc.

        try {
            // Realiza uma requisição para a API para buscar dados semanais com base nos filtros escolhidos
            const response = await fetch(`/dashRegressao/semanal/${selectedTotem}/${selectedComponent}`);

            // Verifica se a resposta da API foi bem-sucedida (status 200 OK)
            if (!response.ok) throw new Error('Erro ao buscar dados do servidor.');

            // Desestrutura os dados retornados pela API em dois objetos: semanaAtual e semanaPassada
            const { semanaAtual, semanaPassada } = await response.json();

            // Array contendo os dias da semana em inglês (formatados para serem usados como referência)
            const diasSemana = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            // Criamos um array `valoresAtuais`, que conterá as médias dos valores do componente atual para cada dia da semana
            const valoresAtuais = diasSemana.map(
                (dia) =>
                    semanaAtual.find((item) => item.dia_semana === dia)?.componente_avg || 0
            );
            /*
                Explicação do `.map`:
                - O método `.map` é usado para transformar os elementos de um array em outro array.
                - Aqui, `diasSemana.map(...)` itera sobre cada dia da semana (ex.: "Sunday", "Monday", etc.).
                - Para cada dia, usamos `.find` para buscar no array `semanaAtual` o item correspondente ao dia da semana.
    
                Explicação do `.find`:
                - O método `.find` retorna o **primeiro elemento** de um array que atende a uma condição.
                - No caso, `semanaAtual.find(item => item.dia_semana === dia)` busca o primeiro objeto em `semanaAtual` 
                  onde o `dia_semana` seja igual ao `dia` atual.
                - Se o objeto é encontrado, obtemos o valor médio (`componente_avg`) usando `?.componente_avg`.
                - O operador `|| 0` retorna 0 caso nenhum item seja encontrado ou `componente_avg` seja `undefined`.
    
                Exemplo:
                - Se `semanaAtual = [{ dia_semana: "Monday", componente_avg: 75 }]`:
                    - Para "Monday", `find` retorna `{ dia_semana: "Monday", componente_avg: 75 }`.
                    - O valor de `componente_avg` será 75.
                    - Para "Tuesday", como não há objeto correspondente, retornamos 0.
            */

            // Fazemos a mesma coisa, mas para a semana passada, criando `valoresPassados`
            const valoresPassados = diasSemana.map(
                (dia) =>
                    semanaPassada.find((item) => item.dia_semana === dia)?.componente_avg || 0
            );

            // Array para armazenar as previsões calculadas usando regressão linear
            const previsoes = [];

            // Laço para calcular as previsões com base nos valores da semana passada
            for (let i = 0; i < diasSemana.length; i++) {
                // Pegamos os valores da semana passada até o índice atual (de 0 a i) usando `.slice`
                const y = valoresPassados.slice(0, i + 1);
                /*
                    Explicação do `.slice`:
                    - O método `.slice(start, end)` retorna uma cópia de uma parte de um array.
                    - `start` é o índice inicial (inclusivo) e `end` é o índice final (exclusivo).
                    - Aqui, `slice(0, i + 1)` retorna os valores do início do array até o índice `i` (inclusive).
                    
                    Exemplo:
                    - Para `valoresPassados = [10, 20, 30, 40]`:
                      - `i = 2`: `slice(0, 2 + 1)` retorna `[10, 20, 30]`.
                */

                // Criamos um array de índices `x` correspondente à quantidade de valores até o índice atual
                const x = Array.from({ length: i + 1 }, (_, idx) => idx);
                /*
                    Explicação do `Array.from`:
                    - `Array.from({ length: n }, callback)` cria um array de tamanho `n` preenchido com os valores gerados pelo callback.
                    - O `_` é um parâmetro ignorado, enquanto `idx` é o índice atual.
    
                    Exemplo:
                    - `Array.from({ length: 3 }, (_, idx) => idx)` retorna `[0, 1, 2]`.
                */

                // Criamos os "pontos" para a regressão no formato [[x1, y1], [x2, y2], ...]
                const pontos = x.map((val, idx) => [val, y[idx]]);
                /*
                    Exemplo:
                    - Se `x = [0, 1, 2]` e `y = [10, 20, 30]`, `pontos` será:
                      [[0, 10], [1, 20], [2, 30]]
                */

                // Aplicamos regressão linear usando a biblioteca `regression`
                const modelo = regression.linear(pontos);
                /*
                    Explicação da Regressão Linear:
                    - A regressão linear busca encontrar a melhor reta que descreve a relação entre `x` (dias) e `y` (valores).
                    - O resultado é uma função do tipo: `y = ax + b`, onde:
                      - `a` é o coeficiente angular (inclinação da reta).
                      - `b` é o coeficiente linear (interseção com o eixo y).
                    - `modelo.predict(x)` retorna o valor de `y` estimado para um dado `x`.
                */

                // Usamos o modelo para prever o valor para o dia `i` (baseado no índice)
                previsoes.push(modelo.predict(i)[1]);
                /*
                    `modelo.predict(i)` retorna um array `[x, y]`.
                    `modelo.predict(i)[1]` é o valor previsto de `y` para o índice `i`.
                */
            }

            // Calculamos a maior e a menor previsão
            const maiorPrevisao = Math.max(...previsoes); // Maior valor no array de previsões
            const menorPrevisao = Math.min(...previsoes); // Menor valor no array de previsões

            // Encontramos os índices da maior e menor previsão
            const indiceMaior = previsoes.indexOf(maiorPrevisao); // Índice do maior valor
            const indiceMenor = previsoes.indexOf(menorPrevisao); // Índice do menor valor

            // Traduzimos os dias correspondentes aos índices encontrados
            const diaMaiorPrevisao = traduzirDia(diasSemana[indiceMaior]);
            const diaMenorPrevisao = traduzirDia(diasSemana[indiceMenor]);

            // Atualizamos o DOM com os dias de maior e menor previsão
            document.getElementById("maiorPrevisao").textContent = diaMaiorPrevisao;
            document.getElementById("menorPrevisao").textContent = diaMenorPrevisao;

            // Atualizamos o ranking de dias com base nos valores reais e nas previsões
            atualizarRanking(diasSemana, valoresAtuais, previsoes);

            // Renderizamos os gráficos com os valores reais e as previsões
            renderChart1(diasSemana, valoresAtuais, previsoes.map(p => p + 10), previsoes.map(p => p - 10));
            renderChart2(diasSemana, valoresAtuais, previsoes);

        } catch (error) {
            // Captura e exibe qualquer erro ocorrido durante o processo
            console.error('Erro ao buscar métricas:', error);
        }
    }





    function atualizarRanking(dias, valoresReais, previsoes) {
        const diasAcima = [];
        const diasAbaixo = [];

        dias.forEach((dia, index) => {
            if (valoresReais[index] > previsoes[index]) {
                diasAcima.push(traduzirDia(dia));
            } else if (valoresReais[index] < previsoes[index]) {
                diasAbaixo.push(traduzirDia(dia));
            }
        });

        const listaAcima = document.getElementById('diasAcima');
        const listaAbaixo = document.getElementById('diasAbaixo');

        listaAcima.innerHTML = diasAcima.map(dia => `<li>${dia}</li>`).join('');
        listaAbaixo.innerHTML = diasAbaixo.map(dia => `<li>${dia}</li>`).join('');
    }

    function renderChart1(dias, valores, previsaoMaxima, previsaoMinima) {
        const selectedComponent = document.getElementById('selectComp').value;
        const chartContainer = document.querySelector("#chart");
        chartContainer.innerHTML = '';

        const options = {
            chart: { type: 'line', height: 292 },
            series: [
                { name: 'Valores Reais', data: valores.map(v => Math.round(v)) },
                { name: 'Previsão Máxima', data: previsaoMaxima.map(v => Math.round(v)) },
                { name: 'Previsão Mínima', data: previsaoMinima.map(v => Math.round(v)) },
                {
                    name: 'Limite (65%)',
                    data: Array(dias.length).fill(65),
                }
            ],
            xaxis: {
                categories: dias.map(traduzirDia),
                labels: { style: { colors: '#ffffff' } }
            },
            yaxis: {
                min: 0,
                max: 100,
                labels: {
                    style: { colors: '#ffffff' },
                    formatter: val => val.toFixed(0)
                }
            },
            stroke: {
                curve: 'smooth',
                width: [3, 3, 3, 2],
                dashArray: [0, 0, 0, 7]
            },
            colors: ['#18204b', '#ff0000', '#1E90FF', '#00ff00'],
            title: {
                text: `Previsão do Percentual Máximo e Mínimo de ${selectedComponent}`,
                align: 'left',
                style: { color: '#ffffff', fontSize: '17px' }
            },
            legend: {
                labels: { colors: '#ffffff' },
                position: 'bottom'
            },
            grid: {
                borderColor: '#ffffff',
                strokeDashArray: 0
            }
        };

        const chart = new ApexCharts(chartContainer, options);
        chart.render();
    }

    function renderChart2(dias, valores, previsoes) {
        const selectedComponent = document.getElementById('selectComp').value;
        const chartContainer2 = document.querySelector("#chart2");
        chartContainer2.innerHTML = '';

        const options = {
            chart: { type: 'line', height: 295, width: 470 },
            series: [
                { name: 'Valores Reais', data: valores.map(v => Math.round(v)) },
                { name: 'Previsão', data: previsoes.map(v => Math.round(v)) },
                {
                    name: 'Limite (65%)',
                    data: Array(dias.length).fill(65),
                }
            ],
            xaxis: {
                categories: dias.map(traduzirDia),
                labels: {
                    style: { colors: '#ffffff' },
                    rotate: -45,
                    hideOverlappingLabels: false
                }
            },
            yaxis: {
                min: 0,
                max: 100,
                labels: {
                    style: { colors: '#ffffff' },
                    formatter: val => val.toFixed(0)
                }
            },
            stroke: {
                curve: 'smooth',
                width: [3, 3, 2],
                dashArray: [0, 0, 7]
            },
            colors: ['#1E90FF', '#18204b', '#00ff00'],
            title: {
                text: `Previsão do Percentual de ${selectedComponent}`,
                align: 'left',
                style: { color: '#ffffff', fontSize: '17px' }
            },
            legend: {
                labels: { colors: '#ffffff' },
                position: 'bottom'
            },
            grid: {
                borderColor: '#ffffff',
                strokeDashArray: 0
            }
        };

        const chart2 = new ApexCharts(chartContainer2, options);
        chart2.render();
    }

    function traduzirDia(dia) {
        const dias = {
            Sunday: 'Domingo',
            Monday: 'Segunda',
            Tuesday: 'Terça',
            Wednesday: 'Quarta',
            Thursday: 'Quinta',
            Friday: 'Sexta',
            Saturday: 'Sábado'
        };
        return dias[dia] || dia;
    }

    async function fetchRanking() {
        try {
            const response = await fetch('/dashRegressao/ranking');
            if (!response.ok) throw new Error('Erro ao buscar ranking.');

            const ranking = await response.json();

            for (let i = 0; i < ranking.length; i++) {
                document.getElementById(`posicao${i + 1}`).textContent = `${i + 1}°`;
                document.getElementById(`nome${i + 1}`).textContent =
                    `Totem ${ranking[i].totem} - ${ranking[i].componente}: ${ranking[i].valor.toFixed(2)}`;
            }

            const { totem, componente } = ranking[0];
            document.getElementById('selectTotem').value = totem;
            document.getElementById('selectComp').value = mapComponentName(componente);

            fetchMetrics();
        } catch (error) {
            console.error('Erro ao buscar ranking:', error);
        }
    }

    function mapComponentName(componente) {
        const mapping = {
            'CPU': 'Cpu',
            'RAM': 'Ram',
            'Disco': 'Disco',
        };
        return mapping[componente] || componente;
    }

    document.addEventListener('DOMContentLoaded', fetchRanking);
    document.addEventListener("DOMContentLoaded", fetchMetrics);
</script>



</html>